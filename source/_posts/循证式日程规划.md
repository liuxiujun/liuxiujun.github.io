---
title: 循证式日程规划
mathjax: true
date: 2020-05-26 11:47:20
tags:
	- 其他
---

作为一个软件开发人员不可避免的要涉及到工时评估的环节，到目前为止自己做过的和看到别人做的日程规划都是马马虎虎，当然其中有很多原因，抛开决策层的一些因素，对如何准确客观的作出一份日程规划，很难找到一种科学、有效的评估方法。

之前用过一些像禅道，redmine之类的项目管理软件，但毫无例外这些东西都变成了开发人员的负担，最后要么变成形式主义的日报周报，要么不得不弃用。对待所谓项目管理工具的态度，我认为这些只能起到辅助作用，期望用一套银弹式的工具彻底解决问题是不现实的。随着管理思维和方法的提升，辅助工具的引入应该是自然而然的事情，甚至可以说只要方法得当，一个简单的excel表格同样也可以优雅的解决问题。而很多时候这两件事情都被搞反了。

软件开发的不可预期性，比如无休止的会议，决策上的善变，复杂度的误判，解决各种bug，指导新手... 几乎没有开发人员相信日程规划是可行的。而这种不可预期在做商业决策的时候是绝对不能被容忍的。部分程序员为了确保按时完成，会在评估的时候加入一些“水分”来平衡这种不可预期，还有一些会因为缺乏经验或乐观主义导致估计不足，从此陷入无休止的加班。

项目上的失败经验下篇再说，这篇主要记录读到Jeol在2007年写下的“循证式日程规划”这种方法，一口气读完非常受益，解答了很多疑惑

来自《软件随想录》以下是文章的笔记。

---

简单来说循证式日程规划最重要的目的之一是收集历史数据（记录每项工作开始时间和结束时间），通过计算得到一条概率分布曲线用来展现在任意给定日期完成工作的可能性有多大。

如果你不搞一个日程规划，程序员就会首先将容易的/有趣的功能做出来。然后，他们剩下的时间就不够了，你别无选择，只好推迟日程来开发有用的或重要的功能。

（1）**分解时间**：任务需要以“小时”为单位进行拆分，`不能有任何任务所需的时间超过16小时`；比如ERP库存模块为例，没有在细节上想清楚工作步骤，就在日程规划上创建一个3周工时的大任务，其实不知道它究竟要花费多少时间；首先需要做的是讨论并将模块拆分为“出库单”，“入库单”，“转储单”，“库存过账记录”等详细的功能并且控制到16小时以内。

（2) **追踪时间的用途**：如何准确的估计完成单个任务所需的时间？考虑到各种莫名其妙的错误，一场接一场的会议，崩溃的Windows系统，Jeol给出的结论是`你不能，真的。`我们能做的只是客观的记录下每项任务的实际时间长度以追踪完成速率，`(完成速率) = (估计用时)/(实际用时)`

> * 传说中完美的估计者，这种人估计用时总是等于实际用时，历史数据就是 {1, 1, 1, 1, 1, ...}
> * 糟糕的估计者，完成速率比较分散，比如 {0.1, 0.5, 1.7, 0.2, 1.2, 0.9, 13.0}
> * 大多数估计者都属于估计不足，但是相对值稳定，因为在这种方法中我们不考虑那些打断我们工作的麻烦问题，历史数据看起来就像 {0.6, 0.5, 0.6, 0.6, 0.5, 0.6, 0.7, 0.6}， 总是小于1

当估计者逐渐变得有经验后，他们估计精度就会提高，以6个月为周期弃用陈旧的数据。

（3）**对未来情况进行模拟**：使用[蒙特卡洛方法](https://wiki.mbalib.com/wiki/蒙特卡罗方法)来计算任意一名程序员在未来任意一种情况下的实际完成时间，具体做法是用每个任务的估计用时去除以这个程序员历史数据（在（2）中得到的数据）中完成速率的一个随机选择的值， 例如：

> | 估计用时:     | 4          | 8          | 2          | 8          | 16         |       |
> | ------------- | :--------- | :--------- | ---------- | ---------- | ---------- | ----- |
> | 随机完成速率: | 0.6 &nbsp; | 0.5 &nbsp; | 0.6 &nbsp; | 0.6 &nbsp; | 0.5 &nbsp; | 总计: |
> | 期望用时:     | 6.7        | 16         | 3.3        | 13.3       | 32         | 71.3  |

对于100种可能发生的情况，重复上面的计算过程，每种情况的可能性是1%，即可以估计出在任意时间节点完成的概率。当前会得到的数据比如 {71.3, 60.1, 55.6, 80.3 ...}

> * 传说中完美的估计者， 在某个日期的完成概率是100%， 完美的不真实
> * 糟糕的估计者，比如从0.1到13这么大的跨度区间会导致概率分布曲线接近于平坦，没有多大的参考价值
> * 普通估计者，期望用时都会比估计用时大出一块，这是对于估计者根深蒂固的乐观主义的一种补偿，这种补偿层度非常准确，因为它是基于程序员一贯的乐观主义的，已经从历史数据中得到证明。

当然在每一轮的蒙特卡洛模拟中，你必须将以小时为单位的数据转化成具体的日历上的日期。这意味着你必须考虑到每一个程序员的工作日程、他们的休息日和假期等。比如将上面的数据转换成{"2020-01-01": 0.01, "2020-01-02": 0.2, "2020-01-05": 0.02 ...} 诸如此类的格式。

Jeol关于日程规划中还得出了另外几条经验

> 1. **只有第一线的程序员才能提出完成日期的估计值。**任何由管理层制定然后交给程序员去执行的日程规划，都注定失败。
> 2. **当新代码出现错误以后，就将解决问题的时间算进你原先写出错误代码的那段用时之中。**这有助于循证式日程规划预计出得到可靠代码所需的时间，而不是得到可以运行的初步代码所需的时间。
> 3. **防止管理层向程序员施加压力，要求加快开发速度。**日程规划并不是一个玩心理游戏的地方。你也许可以多雇几个人，但是新雇员需要一段时间才能赶上别人的速度，开头的几个月他们的效率可能只有别人的50%（他们还降低了指导他们的人的效率）。如果你让手下的团队整个一年都超负荷工作，最终写出来的源代码可能会比正常数量`暂时性地`多出10%。这并不是很大的收益，而且有点类似于你在吃种子粮。
> 4. **一份日程规划就是一个装满木块的盒子。**如果你有一堆木块，你无法将他们装入盒子，你就有两个选择，要么找一个大一点的盒子，要么拿掉几个木块。不要自欺欺人。

---

以上是笔记内容。